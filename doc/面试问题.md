## 4.16

### mysql索引

### 关于索引底层

### 主键索引，非主键索引区别

以mysql两种存储引擎解释(图中辅助键索引即非主键索引)：



 ![img](https://github.com/Bennett-Q/staticRepo/blob/master/images/mysql%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0.png?raw=true) 

  

#### InnoDB:

主键索引也叫聚集索引（或聚簇索引）

 非主键索引的叶子节点存放的是**主键的值**，而主键索引的叶子节点存放的是**整行数据**，其中非主键索引也被称为**二级索引**，而主键索引也被称为**聚簇索引**。



### 数据结构了解下

### 红黑树与B+树比较



###  B+Tree叶节点存放的是什么

key对应的一行数据 data

### springCloud组件说明

### springCloud 为什么配置文件修改能即时生效

### List,Map,Set区别

### hashMap默认容量，怎么扩容

### hashMap怎么插入值的

### hashMap底层，分版本

### hashmap与hashtable区别

### 讲一下concurrentHashMap是否安全，原理



### Synchronized和Reentrantlock 的区别

### Synchronized实现原理

### Reentrantlock 实现原理



### java内存区域，垃圾回收算法

### AQS原理

### 讲一下countDownLatch ,CyclicBarrier ，及应用场景 

### 讲一下线程池，核心参数，线程超负荷之后的应对

## 4.20

### 为什么要用依赖注入，好处是什么

### 2个线程之间如何保持通信

1. wait()  notify() notifyAll() 等待/唤醒线程也是一种通信
2. volatitle 共享变量

### 线程可见性

### volatitle关键字原理

volatitle修饰的变量在主内存（共享内存）中，当有线程修改时，则

### 2个线程如何保持顺序执行

1. BlockingQueue + countDownLanch

### 2个进程如何保持通信

常用的：

1. 消息队列
2. 共享内存
3. Socket

### dockerfile的配置

### springboot比spring好在哪

## 4.21

### spring的aop实现原理

### springboot怎么加载pom中的包

### 讲一讲jdk代理

### 常用的垃圾回收器

https://blog.csdn.net/high2011/article/details/80177473

### 讲一下自定义注解

### jdk1.8新特性

### 内存溢出排查，记录日志，传哪些参数

### 常用线程池，核心参数，会出现的问题

### 常见算法，哪种比较快

https://blog.csdn.net/u013270347/article/details/80604690

## 4.27 

### docker 常用命令



### dockerfile 配置的关键字

- **`FORM`** 指定基础镜像 ，并且必须是第一条指令

```dockerfile
格式：
　　FROM <image>
　　FROM <image>:<tag>
　　FROM <image>@<digest>
示例：
	FROM mysql:5.6
注：
	如果不以任何镜像为基础，那么写法为：FROM scratch
	tag或digest是可选的，如果不使用这两个值时，会使用latest版本的基础镜像
```

- **`MAINTAINER`** 指定维护者信息

```dockerfile
格式:
	MAINTAINER <name>
示例:
	MAINTAINER ZHANG 
	MAINTAINER zhang@163.com
	MAINTAINER 	Qi zhang <zhang@163.com>
```
- **`RUN`** 在镜像中要执行的命令

```dockerfile
RUN用于在镜像容器中执行命令，其有以下两种命令执行方式：
shell执行(command为shell命令)
格式：
    RUN <command>
exec执行(可将executable理解成为可执行文件，后面就是两个参数。)
格式：
    RUN ["executable", "param1", "param2"]
示例：
    RUN ["executable", "param1", "param2"]
    RUN apk update
    RUN ["/etc/execfile", "arg1", "arg1"]
注：　　
	RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定--no-cache参数，如：docker build --no-cache
```

- **`WORKDIR`**  指定当前工作目录，相当于cd

```dockerfile
格式：
    WORKDIR /path/to/workdir
示例：
    WORKDIR /a  (这时工作目录为/a)
    WORKDIR b  (这时工作目录为/a/b)
    WORKDIR c  (这时工作目录为/a/b/c)
注：
　　通过WORKDIR设置工作目录后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT、ADD、COPY等命令都会在该目录下执行。在使用docker run运行容器时，可以通过-w参数覆盖构建时所设置的工作目录。
```

- **`EXPOSE `** 指定容器要打开的端口

```dockerfile
格式：
    EXPOSE <port> [<port>...]
示例：
    EXPOSE 80 443
    EXPOSE 8080    
    EXPOSE 11211/tcp 11211/udp
注：　　
	EXPOSE并不会让容器的端口访问到主机。要使其可访问，需要在docker run运行容器时通过-p来发布这些端口，	或通过-P参数来发布EXPOSE导出的所有端口
```



- **`ENV `** 定义环境变量

```dockerfile
格式：
    ENV <key> <value>  #<key>之后的所有内容均会被视为其<value>的组成部分，因此，一次只能设置一个变量
    ENV <key>=<value> ...  #可以设置多个变量，每个变量为一个"<key>=<value>"的键值对，如果<key>中包含空格，可以使用\来进行转义，也可以通过""来进行标示；另外，反斜线也可以用于续行
示例：
    ENV myName John Doe
    ENV myDog Rex The Dog
    ENV JAVA_OPTS="-Xms512m -Xmx1024m"
    ENV myCat=fluffy
注:
	制定一个环境变量，会被后续RUN指令使用，并在容器运行时保持。
```

- **`ADD`** 将贝蒂文件添加到容器中,tar类型文件会自动解压(网络压缩资源不会被解压),可以访问网络资源,例如wget

```dockerfile
格式：
	 ADD <src>... <dest>
 ADD ["<src>",... "<dest>"] 用于支持包含空格的路径
示例：
 ADD hom* /mydir/          # 添加所有以"hom"开头的文件
 ADD hom?.txt /mydir/      # ? 替代一个单字符,例如："home.txt"
 ADD test relativeDir/     # 添加 "test" 到 `WORKDIR`/relativeDir/
 ADD test /absoluteDir/    # 添加 "test" 到 /absoluteDir/
```



- **`COPY`** 复制本地主机的包,文件之类的到容器中,功能类似于`ADD`,没有ADD功能强大

```dockerfile
格式:
 COPY <src>... <dest>
 COPY ["<src>",... "<dest>"]
示例:
 COPY target/$APP_NAME-*.jar app.jar  
```

- **`ENTRYPOINT`** 配置容器，使其可执行化。配合CMD可省去"application"，只使用参数。

```dockerfile
格式：
    ENTRYPOINT ["executable", "param1", "param2"] (可执行文件, 优先)
    ENTRYPOINT command param1 param2 (shell内部命令)
示例：
    FROM ubuntu
    ENTRYPOINT ["top", "-b"]
    CMD ["-c"]
    ENTRYPOINT exec java -server $JAVA_OPTS -jar /app.jar $PARAMS
注：
	ENTRYPOINT与CMD非常类似，不同的是通过docker run执行的命令不会覆盖ENTRYPOINT，而docker run命令中指定的任何参数，都会被当做参数再次传递给ENTRYPOINT。Dockerfile中只允许有一个ENTRYPOINT命令，多指定时会覆盖前面的设置，而只执行最后的ENTRYPOINT指令。
```

 **举个**🌰

```dockerfile
# This my first nginx Dockerfile
# Version 1.0

# Base images 基础镜像
FROM centos

#MAINTAINER 维护者信息
MAINTAINER tianfeiyu 

#ENV 设置环境变量
ENV PATH /usr/local/nginx/sbin:$PATH

#ADD  文件放在当前目录下，拷过去会自动解压
ADD nginx-1.8.0.tar.gz /usr/local/  
ADD epel-release-latest-7.noarch.rpm /usr/local/  

#RUN 执行以下命令 
RUN rpm -ivh /usr/local/epel-release-latest-7.noarch.rpm
RUN yum install -y wget lftp gcc gcc-c++ make openssl-devel pcre-devel pcre && yum clean all
RUN useradd -s /sbin/nologin -M www

#WORKDIR 相当于cd
WORKDIR /usr/local/nginx-1.8.0 

RUN ./configure --prefix=/usr/local/nginx --user=www --group=www --with-http_ssl_module --with-pcre && make && make install

RUN echo "daemon off;" >> /etc/nginx.conf

#EXPOSE 映射端口
EXPOSE 80

#CMD 运行以下命令
CMD ["nginx"]
```

### jvm回收的算法

### sql优化

### 除了主键索引还有什么索引

### oracle和mysql的区别 (关键字,函数,语法)

### aciveMQ的几种消息方式

### springMVC前台访问后的运行流程

### springBoot配置文件有几种

### ajax跨域请求处理







